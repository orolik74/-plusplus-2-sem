"code golf" -- рейтинг)  
(чтобы в исходниках было наименьшее количество байт, но проходили тесты, .h, .c файлы)  
Это до конца семестра 1. - 3, 2 - 2 (2 человека), 3 - 1 (3 человека)
___

### Ссылки (указатели ++)
```c++
int* pi; // указатель
*pi -> int // разыменовать ссылку
//можно не инициализировать
int *pi;
//есть арифметика указателей
int **//можно указатель на указатель

int& ri; // ссылка, ERR, так как не иниц.
*r; // не валидно, вызов оператора
//нет арифметики указателей
//нельзя ссылку на ссылку
int &&(rvalue); //move-семантика
```

```c++
int x;
int &r = x;
int *p = &x;
```
Похоже на использование переменной, но передается как указатель

**sizeof(T&) == sizeof(T\*)**

Точно так же, как и с указателями:
```c++
void foo(int &x){
    x = 10;
}

int X = 11;
foo(X);
//(X == 10)
```

```c++
int x;
int *px = &x;
int &rx = *px;
int &rx2 = x;
```

С ссылками тяжело сделать подвисший указатель,  
но вот когда это получается:)
```c++
int & foo(){
    int x = 5;
    return x; // UB, ссылка на то, что на стеке функции
}
```

```c++
int & foo(){
    int *x = new int[10];
    int &r = x[5];
    delete []x;
    return r; // неоднозначное определение
    // ссылка на то, что удалили, это общая схема, не обязательно так просто
}
```
В остальном, ссылку _'сломать'_ очень сложно
___
### Структуры и классы
Задание структуры:
```c++
C:
typedef struct str_name_s{
    ...
} str_name_t;

C++:
struct str_name_t
{
    // уровень доступа public:
    ...
};
```
>C: sizeof(empty struct) == 0  
C++: sizeof(empty struct) == 1

в C++ можно использовать имя структуры без struct, но надо помнить, что это не возвращается в C  

Классы:

```c++
class cls_name_t
{
    // неявно уровень доступа private:
    ... 
};
```

```c++
class cls : public Parent, protected PParent, private PrParent
{
    private:
    protected:
    public:
        int x;
        int foo();
        static voi bar();
};

cls::bar()
```
В C++, в отличие от C# есть множественное наследование
(но его не рекомендуется использовать, в том числе из-за того, что это медленно)

модификатор доступа:
* public - все остается как было
* protected - все public -> protected, остальное как было
* private - все -> private

virtual (виртуальное наследование, его наличие обусловдено наличием множественного наследования)  
Если A -> B -> D, A -> C -> D, D приходит из B и из C, если наследование не виртуальное

C -> virtual D  
B -> virtual D // D будет общим у B и C

как таковых интерфейсов нет (как в c#), но можно сделать как структура с чисто виртуальными методами

```c++
//interface
struct IIFace
{
    virtual int Method1() = 0;
    virtual int Method2(int x) = 0;
};
```
___
### Конструкторы
```c++
class cls{
    cls() = default; // только если внутри примитивные типы
    cls() = delete; // нельзя с дефолтным, допустим к любым конструкторам
    cls(const cls& other); // = default; нужно, когда нужно глубокое копирование
    cls(cls&& other); // = default; без глубокого копирования (примеры не сегодня)
    
    ~cls(); // деструктор по умолчанию, сделает тоьлко деструктор очев типов)
    //RAII (Resource Acquisition Is Initialization)
};

//RAII:
{
    cls x;
    
} //-> автоматический вызов деструктора
```
___
### The most vexing parse
(это специфическая ситуация в C++, когда строка кода, которую вы считаете созданием объекта, компилятор воспринимает как объявление функции.)


```c++
class Test{
    Test (int x);
    Test (const Test& other);
};

Test t1(10);
Test t2(Test(5)); // компилятор считает, что это объявление функции

//можно писать:
Test t2{Test{5}}; // {} - как порождение объектов, можно t2{Test(5)}
```
___
### Перегрузка функций
```c++
void foo(int x){}
void foo(short x){}
void foo(bool x){}
void foo(const char * x){}

void main(){
    short s = 123;
    foo(s); // foo(short)
    foo(s + 5); // foo(int)
    foo(true); // foo(bool)
    foo("oops!"); // foo(const char *), если не будет, const ... функции, то это bool, warning не будет
}
```
В тернарном операторе вызывает с типом первого варианта
```c++
foo(cond ?3:3.0) //-> foo(int)
foo(cond ? T1(a) :T2(b)) //->foo(T1)
```