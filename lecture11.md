Из-за присутствия конструктора и деструктора, в C++ приходится внимательнее
следить за временем работы объектов

```c++
int max(int a, int b){
    return a < b ? b : a;
}

int main(){
    int a; // живет отсюда и до конца main
    
    int b; //живет отсюда и до конца main
    
    max(a, b);
}
```

В max(2, 3) создаются временные объекты и живут до конца работы с функцией

Это не сильно важно для встроенных типов, но важно для классов с нетривиальными конструкторами

У функций можно указать параметры по умолчанию, тогда их необязательно передавать
```c++
void startServer(const char* name, int port = 8080, const char * host = "0.0.0.0");

int main(){
    startServer("minecraft", 1000, "0.1.0.1");
    startServer("minecraft")
}
```

Значения по умолчанию -- суффикс аргументов

Особенность, что new/delete вызывают конструктор/деструктор

Можно и через malloc и free, но руками надо вызвать конструктор и деструктор
```c++
Server * server = malloc(sizeof(Server));

new (server) Server(5432); // не выделяет память, просто вызов конструктора

server->~Server(); //руками вызываем деструктор
free(server);
```

Обычно это надо только при реализации структур данных (типа vector),
в большинстве случаев хватает обычных new/delete

Аналогично new[] не только выделит память, но и вызовет конструктор по умолчанию у всех объектов

Хочется не мочь забыть вызвать delete 
Evyst erfpfntkb
```c++
scoped_ptr p = new Object();

```

```c++
class scoped_ptr{
private:
    Object* ptr_;
public:
    scoped_ptr(Object* ptr);
    ~scoped_ptr();
    
    Object* get() const;
    Object& operator *() const;
    explicit operator bool() const();
    
    //Запрет копирования после C++11
    scoped_ptr(const scoped_ptr& other) = delete;
    const scoped_ptr& operator = (const scoped_ptr& p) = delete;
    
private:
    //Запрет копирования до C++11
    scoped_ptr(const scoped_ptr& other);
    const scoped_ptr& operator = (const scoped_ptr& p);
};
```

```c++
scoped_ptr::scoped_ptr(Object* ptr):ptr_(ptr){}
scoped_ptr::~scoped_ptr(){
    delete ptr_;
}
Object* scoped_ptr::get() const{return ptr_;}
//*:=*ptr_;
//->:=ptr_;
```

Запрет копирования нужен, чтобы не ссылались на один объект несколько указателей и
случайно не удалили его, когда мы не хотели
 
Как работает operator ->?
Возвращаем либо указатель(с дефолтным ->, он его вызовет), иначе рекурсивно идем до простого указателя

>scoped_ptr: нельзя копировать, нельзя передавать владение объектам(напр. в функцию или из функции), 
живет внутри одного scope(его), только один scoped_ptr указывает на объект

>unique_ptr: нельзя копировать, можно перемещать, можно передать владение, только один unique_ptr 
указывает на объект

>shared_ptr: можно копировать(можно передавать владение), несколько shared_ptr могут указывать на один 
объект

RMK: на самом деле, умные указатели - это шаблоны классов

Как хотим реализовать shared_ptr?  
Идея: храним счетчик ссылок  
Если счетчик == ноль => можем удалить объект

RMK: не подходит, если есть циклические ссылки

Счетчик ссылок должен быть общим между всеми копиями 

```c++
class shared_ptr{
private:
    struct storage{
        std::size_t refcount = 0;
        Object* pointer = nullptr;
    };
    storage* storage_;
public:
    ...    
};
```

Настоящий shared_ptr устроен сложнее  
Позволяет передавать произвольную функцию удаления(по дефолту delete)  
Позволяет ссылаться на часть объекта  
Позволяет разбить циклические ссылки или узнать об удалении объекта через weak_ptr

### Наследование

1. Композиция: один класс является полем другого
2. Наследование: один является другим с надстройкой

```c++
class ColoredButton: public Button, ...{};
```

Button -- базовый класс
ColoredButton -- класс-наследник(или производный класс)

Конструктор класса-наследника должен вызвать конструктор базового класса
(как и с полями констр. без арг.)  
Деструктор автоматически вызовет деструктор базового класса  
Указатель на класс-наследник приводится к типу указатель на базовый класс

Хотим обрабатывать разные объекты одним и тем же кодом:
```c++
Button* buttons[3];
buttons[0] = new Button("Save");
buttons[1] = new Button("Load");
buttons[2] = new ColloredButton("Quit", Color::Blue);

void drawUI(){
    for (int i = 0; i < 3; ++i){
        buttons[i]->draw(); // для buttons[2] будет вызвана функция как Button
    }
}
```

virtual говорит компилятору, что при вызове этого метода надо посмотреть, какой на самом деле класс лежит
по этому указателю, и вызвать правильный метод

Обычно, если есть зотя бы 1 virtual метод, то надо сделать virtual деструктор

Если наследование не public, то не будет приведения к указателю на базовый тип

```c++
class A: B
{
    X x;
};
===
class A: private B
{
    private:
     X x;
};

struct A: B
{
    X x;
};
===
struct A: public B
{
    public:
     X x;
};
```

