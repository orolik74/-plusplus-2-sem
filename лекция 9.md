# Лекция 9, ссылки, перегрузка функций, new и delete,ООП, классы, инкапсуляция

### Документация:
C++ standard draft
eel.is/c++draft
https://cppreference.com/
___
#### Компиляция
Компиляция работает так же, как и в C

Исходный код делится на файлы, которые компилируются по
отдельности, и собираются вместе линковщиком в
результирующую программу/библиотеку

Обычно расширения <mark style="background: #FFB86CA6;">.cpp</mark>, реже .cxx, .cc
Заголовочные файлы: .h, <mark style="background: #FFB86CA6;">.hpp</mark>(чтобы отличать от C), реже .hh, .hxx
<mark style="background: #BBFABBA6;">RMK</mark>: Заголовочные файлы стандартной библиотеки C++ не
имеют расширения, напр.
```C++
#include <thread>
```
___
#### Приведения типов
C++ наследует почти все, что есть в C
Самое важное, что не наследует - неявные приведения типов, в C++ их нет

```C++
nt *pi = ...;
char *pc = ...;

// Можно в C, ошибка компиляции в C++
pi = pc;

// В C++ нужно явное приведение типа
pi = (int*)pc;

// Приводить к void* в C++ всё ещё можно
void *pv = pi;

// Но не обратно (ошибка компиляции в C++)
pc = pv
```

___
#### new/delete
В C++ используют не malloc/free, а <mark style="background: #FFB86CA6;">new/delete</mark>
```C++
// Аналог malloc(sizeof(int))
int *pi = new int;

// Аналог free(pi)
delete pi;

// Аналог malloc(N * sizeof(int))
int *array = new int[N];

// Аналог free(array)
delete [] array; // [] нужны для того, чтобы понимали, что это был массив
```
new и delete – операторы языка, они обрабатываются напрямую компилятором, и знают про тип, который выделяется
* Указатели, выделенные с помощью malloc, нужно освобождать с помощью free 
* Указатели, выделенные с помощью new, нужно освобождать с помощью delete 
* Указатели, выделенные с помощью new[], нужно освобождать с помощью delete[]

Они внутри работают по-разному, поэтому если использовать не их пару, то произойдет UB
___
#### ссылки(references)

Указатели – один из основных инструментов в C, но бывают неудобны:
* Нужно помнить про взятие адреса &x и разыменовывание *p
* Могут быть нулевыми int * p = NULL;
* Адрес, на который они указывают, может меняться p = &x


В C++ есть альтернатива: ссылки

Тип ссылки на тип T -- T& (int& -- int)

```c++
int x = ...;

// Здесь & - не взятие адреса, а часть типа
// int& означает ссылку на int
int &ref = x;

// Ссылку обязательно нужно проинициализировать!
int &ref2; // Ошибка компиляции

// Ссылку нельзя перенаправить на другой объект
int y = 42;

ref = y; // присваивает переменной x значение 42
// ref всё ещё указывает на x

//разыменование указателя возвращает ссылку
int *p = ...;
int &ref = *p;

//у ссылки можно взять адрес, получится адрес объекта, на который она указывает
int *q = &ref;
assert(p == q);
```
В целом, ссылка на объект ведёт себя как синоним имени этого объекта

Самый близкий аналог в C - T * const, но без операторов взятия адреса и разыменовывания

В бинарном виде это то же самое, что простой указатель

Ссылки могут указывать на константный и на неконстантный объект
```c++
int x = ...;
int &ref = x;
const int &cref = x;

//через неконстантную ссылку можно менять значение переменной
ref = 42;

const int y = ...;
int &yref = y; //CE, нельзя взять неконстантную ссылку на конст. переменную
```
