# Лекция 9, ссылки, перегрузка функций, new и delete,ООП, классы, инкапсуляция

### Документация:
C++ standard draft
eel.is/c++draft
https://cppreference.com/
___
#### Компиляция
Компиляция работает так же, как и в C

Исходный код делится на файлы, которые компилируются по
отдельности, и собираются вместе линковщиком в
результирующую программу/библиотеку

Обычно расширения <mark style="background: #FFB86CA6;">.cpp</mark>, реже .cxx, .cc
Заголовочные файлы: .h, <mark style="background: #FFB86CA6;">.hpp</mark>(чтобы отличать от C), реже .hh, .hxx
<mark style="background: #BBFABBA6;">RMK</mark>: Заголовочные файлы стандартной библиотеки C++ не
имеют расширения, напр.
```C++
#include <thread>
```
___
#### Приведения типов
C++ наследует почти все, что есть в C
Самое важное, что не наследует - неявные приведения типов, в C++ их нет

```C++
nt *pi = ...;
char *pc = ...;

// Можно в C, ошибка компиляции в C++
pi = pc;

// В C++ нужно явное приведение типа
pi = (int*)pc;

// Приводить к void* в C++ всё ещё можно
void *pv = pi;

// Но не обратно (ошибка компиляции в C++)
pc = pv
```

___
#### new/delete
В C++ используют не malloc/free, а <mark style="background: #FFB86CA6;">new/delete</mark>
```C++
// Аналог malloc(sizeof(int))
int *pi = new int;

// Аналог free(pi)
delete pi;

// Аналог malloc(N * sizeof(int))
int *array = new int[N];

// Аналог free(array)
delete [] array; // [] нужны для того, чтобы понимали, что это был массив
```
new и delete – операторы языка, они обрабатываются напрямую компилятором, и знают про тип, который выделяется
* Указатели, выделенные с помощью malloc, нужно освобождать с помощью free 
* Указатели, выделенные с помощью new, нужно освобождать с помощью delete 
* Указатели, выделенные с помощью new[], нужно освобождать с помощью delete[]

Они внутри работают по-разному, поэтому если использовать не их пару, то произойдет UB
___
#### ссылки(references)

Указатели – один из основных инструментов в C, но бывают неудобны:
* Нужно помнить про взятие адреса &x и разыменовывание *p
* Могут быть нулевыми int * p = NULL;
* Адрес, на который они указывают, может меняться p = &x


В C++ есть альтернатива: ссылки

Тип ссылки на тип T -- T& (int& -- int)

```c++
int x = ...;

// Здесь & - не взятие адреса, а часть типа
// int& означает ссылку на int
int &ref = x;

// Ссылку обязательно нужно проинициализировать!
int &ref2; // Ошибка компиляции

// Ссылку нельзя перенаправить на другой объект
int y = 42;

ref = y; // присваивает переменной x значение 42
// ref всё ещё указывает на x

//разыменование указателя возвращает ссылку
int *p = ...;
int &ref = *p;

//у ссылки можно взять адрес, получится адрес объекта, на который она указывает
int *q = &ref;
assert(p == q);
```
В целом, ссылка на объект ведёт себя как синоним имени этого объекта

Самый близкий аналог в C - T * const, но без операторов взятия адреса и разыменовывания

В бинарном виде это то же самое, что простой указатель

Ссылки могут указывать на константный и на неконстантный объект
```c++
int x = ...;
int &ref = x;
const int &cref = x;

//через неконстантную ссылку можно менять значение переменной
ref = 42;

const int y = ...;
int &yref = y; //CE, нельзя взять неконстантную ссылку на конст. переменную
```
Аргументы функций могут быть ссылками
```c++
void swap(int &x, int &y){
    int temp = x;
    x = y;
    y = temp;
}
//для вызова функции swap не нужны операторы взятия адреса:
int a = 3, b = 5;
swap(a, b);
```
<mark style="background: #BBFABBA6;">RMK</mark> У этого есть и минус, при вызове функции не понятно они передаются по ссылке или копируются

___
#### Перегрузка функций (function overload)

В C++ можно перегружать функции, но они должны отличаться аргументами, либо их количеством, либо типами

```c++
int max(int x, int y) {..}

int max(int x, int y, int z) {..}

double max(int x, int y) {..} //Ошибка компиляции: отличается только тип возвращаемого значения

double max(double x, int y) {..}// OK - отличается тип первого аргумента
```
Это полезно, если нужно реализовывать похожую логику для разных типов

Приколы с линковкой: при линковке надо подставить адрес функции в нужные места, надо их как-то теперь отличать и понимать, что нужно

Есть 2 подхода:
1. Научить линковщик понимать все правила перегрузки, но это очень-очень сложно
2. Научить его различать разные функции, для этого используют name mangling (коверкание имен)

**При компиляции C++ имена функций преображаются компилятором так, чтобы функции с разным количеством/типами аргументов превращались в разные mangled имена**

Конкретный алгоритм преобразования зависит от системы и компилятора (т.е. является частью ABI)

Под Linux можно узнать mangled имена командой
readelf -s file.o:
```c++
// -> _Z3maxii
int max(int x, int y) { ... }
// -> _Z3maxiii
int max(int x, int y, int z) { ... }
// -> _Z3maxff
double max(float x, float y) { ... }
// -> _Z3maxPcS_
char * max(char *p, char * q) { ... }
```
godbolt.org

чтобы имена не коверкали пишем так:
```c++
extern "C" int max(...) // функция из C
```
С хедеры часто имеют такое:
```c++
#ifdef __cplusplus
    extern "C"{
#endif
...
#ifdef __cplusplus
}
#endif
```
___
#### C++ - ООП язык
Правильнее сказать, что C++ поддерживает ООП парадигму, вообще на C++ можно писать и без ООП

ООП реализуется посредством классов

Проще всего смотреть на классы как на навороченные структуры (по крайней мере пока что)

```c++
// Array - имя типа, аналогично структурам в С
class Array {
    // Поля (данные) класса, аналогично структурам в C
    int *data;
    size_t size;
    
    // Методы: функции, которые можно вызывать у объектов класса
    void set(size_t index, int value);
    void fill(int value);
};
```
Динамический массив без классов:
```c++
int *array = new int[size];
//что-то делаем с массивом
delete [] array;
```
Плохо, что нужно запоминать много всего, не выходить за границы и тд

```c++
// array.h
class Array {
    // Инкапсуляция: приватные поля недоступны снаружи объекта
    private:
    size_t size;
    int *data;
    
    // Публичный интерфейс класса
    public:
    
    // Конструктор - создаёт объект
    Array(size_t size);
    
    // Деструктор - удаляет объект
    ~Array();
    // Доступ к элементам
    int get(size_t index);
    void set(size_t index, value);
};
```
```c++
// array.сpp

// Реализация конструктора
Array::Array(size_t size) {
// this - указатель на объект, у которого вызвали метод
    this->size = size; // здесь this->size нужно только потому что 
    // поле и аргумент имеют одно имя
    data = new int[size];
}

// Реализация деструктора
Array::~Array() {
    delete[] data;
}

// Реализация методов
int Array::get(size_t index) {
    return data[index];
}
void Array::set(size_t index, value) {
    data[index] = value;
}

```
```c++
#include <array.h>
void test_array() {
    // Вызов конструктора, size = 100
    Array a(100);
    
    // Ошибка компиляции: нет параметра конструктора
    Array b;
    
    // Ошибка компиляции: data - приватное поле
    a.data[10] = 42;
    
    // OK, вызов метода класса
    a.set(10, 42);
    
    // Здесь автоматически(!) вызовется деструктор a
    // Как будто мы написали a.~Array() (не надо так писать самим!)
}
```
* int x;
  * int – тип переменной
  * x – имя переменной
* Array a;
  * Array – класс (class) (он в том числе является типом!)
  * a – объект/экземпляр (object/instance) класса (во многом
  ведёт себя как переменная)
  * data – поле (field/member) класса
  * set() – метод (method) класса

Добавим метод получения размера массива
```c++
class Array{
    ...
    public:
    ...
    size_t get_size(){
        return size;
    }
}
```
Пришлось назвать метод get_size(), потому что у нас есть поле size, чтобы не было конфликтов

Из-за этого часто приватные поля называют с префиксами/суффиксами mSize (m от member) или size_

<mark style="background: #BBFABBA6;">RMK</mark> лучше не использовать префикс '_' или '__', так как они могут быть зарезервированы

Конструктор класса можно перегружать
```c++
// array.h
class Array {
    ...
    public:
    // Выделить память, оставить непроинициализированной
    Array(size_t size);
    // Выделить память, заполнить значением value
    Array(size_t size, int value);
    // Создать массив нулевого размера
    Array();
};
```
```c++
// array.cpp
Array::Array(size_t size) {
    this->size = size;
        data = new int[size];
    }
    Array::Array(size_t size, int value) {
        this->size = size;
        data = new int[size];
        for (size_t i = 0; i < size; ++i)
        data[i] = value;
    }
    Array::Array() {
        size = 0;
        data = nullptr; // более безопасный аналог NULL
    }
}
```
Конструктор без аргументов называют конструктор по умолчанию (default constructor)

Его **НУЖНО** вызывать без скобок, если вызвать со скобками это может считаться объявлением функции

```c++
Array a; // OK, так и надо

Array a(); // НЕ ok
```

Если не определить конструктор и/или деструктор, то компилятор сделает их автоматически
```c++
Array::Array(){}
Array::~Array(){}
```

Конструкторы и деструкторы класса всегда автоматически вызывают конструкторы/деструкторы всех полей
```c
typedef struct {
    size_t size;
    int *data;
} array_t;

void init(array_t *array, size_t size) {
    array->size = size;
    array->data = malloc(size * sizeof(int));
}

void destroy(array_t *array) {
    free(array->data);
}

int main() {
    array_t a;
    init(&a, 100);
    destroy(&a);
}
```
Компилятор превращает код с классами во что-то похожее на **C-style инкапсуляцию**

Все **проверки** на public/private происходят **во время компиляции**, в бинарном коде они уже не нужны

Методы класса превращаются в функции, принимающие дополнительный параметр _this_ (часто у таких функций другой calling convention, см. thiscall)

Конструкторы и деструкторы, аналогично методам, превращаются в функции, и вызываются компилятором автоматически в нужных местах